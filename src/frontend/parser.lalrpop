grammar;

// Bring in our AST types.
use crate::frontend::ast::*;

// Top-level production.
pub Program: Program = {
    <stmts:Stmt*> => Program::Stmts(stmts),
};

// A block is a series of statements enclosed in braces.
Block: Vec<Stmt> = {
    "{" <stmts:Stmt*> "}" => stmts,
};

// Extend Stmt to include control flow constructs.
Stmt: Stmt = {
    <decl:Decl> ";" => Stmt::Decl(decl),
    <expr:Expr> ";" => Stmt::Expr(expr),
    "if" "(" <cond:Expr> ")" <then_block:Block> "else" <else_block:Block> => {
        Stmt::IfElse { condition: cond, then_block, else_block }
    },
    "if" "(" <cond:Expr> ")" <then_block:Block> => {
        Stmt::If { condition: cond, then_block: then_block }
    },
    "while" "(" <cond:Expr> ")" <body:Block> => {
        Stmt::While { condition: cond, body }
    },
    "for" "(" <init:Stmt> <cond:Expr> ";" <inc:Expr> ")" <body:Block> => {
        Stmt::For { init: Box::new(init), condition: cond, increment: inc, body }
    },
};

// Declarations.
Decl: Decl = {
    "int" <id:Ident> "=" <expr:Expr> => Decl::VarDecl { typ: Type::Int, name: id, init: Some(expr) },
    "int" <id:Ident> => Decl::VarDecl { typ: Type::Int, name: id, init: None },
};

// Identifier lexer rule.
Ident: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>),
};

// Expression: start with assignment.
Expr: Expr = {
    <assign:AssignExpr> => assign,
};

// Assignment expression.
AssignExpr: Expr = {
    <id:Ident> "=" <rhs:AssignExpr> => Expr::Assign(Box::new(Expr::Var(id)), Box::new(rhs)),
    <add:AddExpr> => add,
};

// Addition and subtraction.
AddExpr: Expr = {
    <l:AddExpr> "+" <r:MulExpr> => Expr::BinaryOp(Box::new(l), BinOp::Add, Box::new(r)),
    <l:AddExpr> "-" <r:MulExpr> => Expr::BinaryOp(Box::new(l), BinOp::Sub, Box::new(r)),
    <mul:MulExpr> => mul,
};

// Multiplication and division.
MulExpr: Expr = {
    <l:MulExpr> "*" <r:PrimaryExpr> => Expr::BinaryOp(Box::new(l), BinOp::Mul, Box::new(r)),
    <l:MulExpr> "/" <r:PrimaryExpr> => Expr::BinaryOp(Box::new(l), BinOp::Div, Box::new(r)),
    <prim:PrimaryExpr> => prim,
};

// Primary expressions.
PrimaryExpr: Expr = {
    r"[0-9]+" => Expr::Literal(<>.parse().unwrap()),
    <id:Ident> => Expr::Var(id),
    "(" <e:Expr> ")" => e,
};